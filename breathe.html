<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Breathe Tracker</title>
<style>
  :root{
    --bg: #f0f6fb; --card:#ffffff; --accent:#2563eb; --muted:#64748b; --ok:#16a34a;
  }
  *{box-sizing:border-box}
  body{
    margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(134deg,#eef7ff,blue);
    color:#0f1724;padding:100px;min-height:100vh;display:flex;align-items:center;justify-content:center;
  }
  .wrap{width:70%;max-width:1000px;display:grid;grid-template-columns:1fr;gap:20px;}

  h1{margin:0;font-size:45px;text-align: center;}
  p.lead{margin:6px 0 12px;color:var(--muted)}

  .card{background:var(--card);border-radius:12px;padding:16px;box-shadow:0 10px 30px rgba(2,6,23,0.06);margin-right: 30px;}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  label{font-size:0.9rem;color:var(--muted)}
  .row{display:flex;gap:10px;align-items:center;margin-top:10px}
  input[type="number"],select{padding:8px;border-radius:8px;border:1px solid #e6eef8;background:#fbfdff}
  input[type="range"]{width:100%}
  button{background:var(--accent);color:white;border:none;padding:10px 12px;border-radius:10px;cursor:pointer;font-weight:600}
  button.ghost{background:transparent;color:var(--accent);border:1px solid rgba(37,99,235,0.12)}
  button.warn{background:#ef4444}
  .small{font-size:0.9rem;color:var(--muted)}

  /* visual circle */
  .canvas{
    display:flex;flex-direction:column;align-items:center;justify-content:center;gap:12px;padding:18px;
    text-align:center;
  }
  .ring{
    width:220px;height:220px;border-radius:50%;display:flex;align-items:center;justify-content:center;
    background:radial-gradient(circle at 35% 20%, rgba(37,99,235,0.08), rgba(99,102,241,0.02)), #fff;
    box-shadow: 0 10px 30px rgba(37,99,235,0.06);transition:transform 1s linear;
  }
  .ring.grow{transform:scale(1.15)}
  .phase{font-size:1.1rem;font-weight:700}
  .count{font-size:2.2rem;font-weight:800;color:var(--accent)}

  .preset-list{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;justify-content: center;}
  .pill{padding:8px 10px;border-radius:999px;border:1px solid #eef4ff;background:#fff;cursor:pointer}
  .pill.active{background:linear-gradient(90deg,var(--accent),#60a5fa);color:#fff;border-color:transparent;box-shadow:0 8px 30px rgba(37,99,235,0.12)}

  .history-list{max-height:340px;overflow:auto;margin-top:8px}
  .entry{padding:10px;border-radius:8px;background:#fbfdff;margin-bottom:8px;border-left:4px solid #e6eef8}
  .meta{font-size:0.85rem;color:var(--muted)}

  @media (max-width:920px){
    .wrap{grid-template-columns:1fr; padding-bottom:60px}
  }
</style>
</head>
<body>
  <div class="wrap">
    <!-- left: visual + controls -->
    <div class="card canvas" aria-live="polite">
      <div style="width:100%;display:flex;justify-content:space-between;align-items:center;">
        <div>
          <h1>&#9679 Breathe Tracker &#9679<br>═══════</h1>
          <p class="lead">Follow the visual guide to inhale, hold, and exhale. Choose presets or customize your own.</p>
        </div>
        <div class="small">Version 1.0</div>
      </div>

      <div class="ring" id="ring" aria-hidden="true">
        <div style="text-align:center">
          <div class="phase" id="phaseLabel">Ready</div>
          <div class="count" id="timeLabel">00</div>
          <div class="small" id="cycleLabel">Cycles: 0 / 0</div>
        </div>
      </div>

      <div class="row" style="width:100%">
        <button id="startBtn">Start</button>
        <button class="ghost" id="pauseBtn" disabled>Pause</button>
        <button class="ghost" id="stopBtn" disabled>Stop</button>
        <button class="ghost" id="skipBtn" disabled>Skip Phase</button>
      </div>

      <div class="row" style="width:100%;margin-top:12px">
        <label class="small" style="min-width:110px">Phases (s):</label>
        <div style="flex:1">
          <div style="display:flex;gap:8px">
            <div style="flex:1"><label class="small">Inhale</label><input id="inhale" type="number" min="1" value="4"/></div>
            <div style="flex:1"><label class="small">Hold</label><input id="hold" type="number" min="0" value="4"/></div>
            <div style="flex:1"><label class="small">Exhale</label><input id="exhale" type="number" min="1" value="4"/></div>
            <div style="flex:1"><label class="small">Hold2</label><input id="hold2" type="number" min="0" value="0"/></div>
          </div>
        </div>
      </div>

      <div class="row" style="width:100%;margin-top:10px">
        <label class="small" style="min-width:110px">Cycles:</label>
        <input id="cycles" type="number" min="1" value="6" style="width:120px;padding:8px;border-radius:8px;border:1px solid #e6eef8"/>
        <label class="small" style="margin-left:auto"><input type="checkbox" id="soundToggle"/> Sound</label>
      </div>

      <div style="width:100%;margin-top:12px">
        <div class="small">Presets:</div>
        <div class="preset-list" id="presets">
          <div class="pill" data-inhale="4" data-hold="4" data-exhale="4" data-hold2="0" data-cycles="6">4-4-4</div>
          <div class="pill" data-inhale="4" data-hold="7" data-exhale="8" data-hold2="0" data-cycles="4">4-7-8</div>
          <div class="pill" data-inhale="5" data-hold="0" data-exhale="5" data-hold2="0" data-cycles="8">Relax 5-5</div>
          <div class="pill" id="customPreset" style="border-style:dashed">Custom</div>
        </div>
      </div>
    </div>

    <!-- right: settings + history -->
    <div class="card">
      <h3 style="margin-top:0">Session Summary</h3>
      <div class="small" id="summary">No session yet</div>

      <hr style="margin:12px 0;border:0;border-top:1px solid #f0f5ff"/>

      <h3 style="margin:0 0 8px 0">History</h3>
      <div class="history-list" id="historyList" aria-live="polite"></div>
      <div style="display:flex;gap:8px;margin-top:12px">
        <button class="ghost" id="exportBtn">Export CSV</button>
        <button class="ghost" id="clearBtn">Clear History</button>
      </div>
    </div>
  </div>

<script>
/* Breathe Tracker JS */
(() => {
  const ring = document.getElementById('ring');
  const phaseLabel = document.getElementById('phaseLabel');
  const timeLabel = document.getElementById('timeLabel');
  const cycleLabel = document.getElementById('cycleLabel');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const stopBtn = document.getElementById('stopBtn');
  const skipBtn = document.getElementById('skipBtn');
  const inhaleInput = document.getElementById('inhale');
  const holdInput = document.getElementById('hold');
  const exhaleInput = document.getElementById('exhale');
  const hold2Input = document.getElementById('hold2');
  const cyclesInput = document.getElementById('cycles');
  const soundToggle = document.getElementById('soundToggle');
  const presetsWrap = document.getElementById('presets');
  const historyList = document.getElementById('historyList');
  const summary = document.getElementById('summary');

  const STORAGE = 'breathe_history_v1';

  // State
  let session = null; // {phases:[], cyclesTotal, currentCycle, currentPhaseIndex, remaining, running, paused, startTime}
  let tickTimer = null; // interval for updating countdown
  let phaseTimeout = null;
  let audioCtx = null;

  const PHASE_LABELS = { inhale: 'Inhale', hold: 'Hold', exhale: 'Exhale' };

  // Helpers
  function beep(freq=440, dur=0.08){
    if(!soundToggle.checked) return;
    try{
      if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'sine';
      o.frequency.value = freq;
      o.connect(g); g.connect(audioCtx.destination);
      g.gain.value = 0.0001;
      g.gain.exponentialRampToValueAtTime(0.12, audioCtx.currentTime + 0.01);
      o.start();
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
      o.stop(audioCtx.currentTime + dur + 0.02);
    }catch(e){ /* ignore audio errors */ }
  }

  function loadHistory(){ try{ return JSON.parse(localStorage.getItem(STORAGE))||[] }catch(e){ return [] } }
  function saveHistory(arr){ localStorage.setItem(STORAGE, JSON.stringify(arr)); renderHistory(); }

  function formatTime(s){ return String(Math.ceil(s)).padStart(2,'0') + 's'; }

  // Build phase array from inputs
  function buildPhases(){
    const inh = Math.max(1, Number(inhaleInput.value)||4);
    const hold = Math.max(0, Number(holdInput.value)||0);
    const exh = Math.max(1, Number(exhaleInput.value)||4);
    const hold2 = Math.max(0, Number(hold2Input.value)||0);
    // include holds only if >0
    const phases = [];
    phases.push({key:'inhale', label:PHASE_LABELS.inhale, duration:inh});
    if(hold>0) phases.push({key:'hold', label:PHASE_LABELS.hold, duration:hold});
    phases.push({key:'exhale', label:PHASE_LABELS.exhale, duration:exh});
    if(hold2>0) phases.push({key:'hold', label:PHASE_LABELS.hold, duration:hold2});
    return phases;
  }

  // Start session
  function startSession(){
    if(session && session.running){
      // already running
      return;
    }
    const phases = buildPhases();
    const cyclesTotal = Math.max(1, Number(cyclesInput.value)||6);
    session = {
      phases, cyclesTotal, currentCycle:0, currentPhaseIndex:0,
      remaining: phases[0].duration, running:true, paused:false, startTime: Date.now(), completedCycles:0
    };
    startBtn.disabled = true;
    pauseBtn.disabled = false; stopBtn.disabled = false; skipBtn.disabled = false;
    runPhase(); // start first phase
    tickTimer = setInterval(updateCountdown, 200);
    updateSummary();
  }

  // Pause / Resume
  function pauseSession(){
    if(!session) return;
    if(!session.paused){
      // pause
      session.paused = true;
      session.running = false;
      clearTimeout(phaseTimeout);
      clearInterval(tickTimer);
      pauseBtn.textContent = 'Resume';
      ring.style.transition = 'transform 0.3s linear';
    } else {
      // resume
      session.paused = false;
      session.running = true;
      pauseBtn.textContent = 'Pause';
      // continue current phase with remaining time
      runPhase(session.remaining);
      tickTimer = setInterval(updateCountdown,200);
    }
  }

  // Stop session
  function stopSession(){
    if(!session) return;
    clearTimeout(phaseTimeout);
    clearInterval(tickTimer);
    session = null;
    startBtn.disabled = false;
    pauseBtn.disabled = true; pauseBtn.textContent = 'Pause';
    stopBtn.disabled = true; skipBtn.disabled = true;
    phaseLabel.textContent = 'Stopped';
    timeLabel.textContent = '00';
    cycleLabel.textContent = 'Cycles: 0 / 0';
    ring.classList.remove('grow');
    updateSummary();
  }

  // Skip phase
  function skipPhase(){
    if(!session || !session.running) return;
    clearTimeout(phaseTimeout);
    runNextPhase();
  }

  // Run a phase (optionally with provided duration override)
  function runPhase(overrideDuration){
    if(!session) return;
    // ensure phase index valid
    if(session.currentPhaseIndex >= session.phases.length){
      // finish cycle
      session.currentCycle++;
      session.completedCycles++;
      if(session.currentCycle >= session.cyclesTotal){
        // session complete
        finishSession();
        return;
      } else {
        // next cycle start
        session.currentPhaseIndex = 0;
      }
    }
    const phase = session.phases[session.currentPhaseIndex];
    const duration = overrideDuration !== undefined ? overrideDuration : phase.duration;
    session.remaining = duration;
    phaseLabel.textContent = phase.label;
    timeLabel.textContent = formatTime(session.remaining);
    cycleLabel.textContent = `Cycles: ${Math.min(session.completedCycles+ (session.currentPhaseIndex>0?1:0), session.cyclesTotal)} / ${session.cyclesTotal}`;
    // set ring animation: grow on inhale, shrink on exhale/hold
    if(phase.key === 'inhale'){
      ring.classList.add('grow');
      ring.style.transition = `transform ${duration}s linear`;
    } else if(phase.key === 'exhale'){
      ring.classList.remove('grow');
      ring.style.transition = `transform ${duration}s linear`;
    } else {
      // hold - keep current state but transition smooth
      ring.style.transition = `transform ${duration}s linear`;
    }

    // beep at phase start
    beep(640,0.08);

    // schedule end of phase
    phaseTimeout = setTimeout(()=> runNextPhase(), duration*1000);
  }

  function runNextPhase(){
    if(!session) return;
    // move to next phase
    session.currentPhaseIndex++;
    // if beyond phases, runPhase will handle cycle increment
    runPhase();
  }

  function finishSession(){
    // add to history
    const now = new Date();
    const totalSeconds = Math.round((now - session.startTime)/1000);
    const record = {
      date: now.toLocaleString(),
      cycles: session.completedCycles,
      totalSeconds,
      config: session.phases.map(p=>`${p.label}:${p.duration}s`).join(' | ')
    };
    const hist = loadHistory();
    hist.push(record);
    saveHistory(hist);
    // visual & state reset
    showToast(`Session complete — ${record.cycles} cycles (${record.totalSeconds}s)`);
    stopSession();
    updateSummary(record);
  }

  function updateCountdown(){
    if(!session || !session.running) return;
    // decrement remaining by elapsed estimate: we'll simply reduce using timestamps for better precision
    // store last tick
    if(!session._lastTick) session._lastTick = Date.now();
    const now = Date.now();
    const elapsed = (now - session._lastTick)/1000;
    session._lastTick = now;
    session.remaining = Math.max(0, session.remaining - elapsed);
    timeLabel.textContent = formatTime(session.remaining);
    // if remaining approx 0, do nothing because setTimeout handles phase end
  }

  // UI helpers
  function updateSummary(latest){
    const hist = loadHistory();
    if(latest){
      summary.innerHTML = `<strong>Last:</strong> ${latest.date} — ${latest.cycles} cycles, ${latest.totalSeconds}s <div class="small" style="margin-top:6px">${latest.config}</div>`;
      return;
    }
    if(hist.length===0){
      summary.textContent = 'No session yet';
    } else {
      const last = hist[hist.length-1];
      summary.innerHTML = `<strong>Last:</strong> ${last.date} — ${last.cycles} cycles, ${last.totalSeconds}s`;
    }
  }

  function renderHistory(){
    const hist = loadHistory();
    historyList.innerHTML = '';
    if(hist.length===0){
      historyList.innerHTML = '<div class="small">No sessions yet. Start a session to save it here.</div>';
      return;
    }
    hist.slice().reverse().forEach((h, idx)=>{
      const el = document.createElement('div'); el.className = 'entry';
      el.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div style="font-weight:700">${h.date}</div>
          <div class="meta">${h.cycles} cycles • ${h.totalSeconds}s</div>
          <div class="meta" style="margin-top:6px">${h.config}</div>
        </div>
        <div style="text-align:right">
          <button class="ghost" data-index="${hist.length-1-idx}">Delete</button>
        </div>
      </div>`;
      historyList.appendChild(el);
    });
    // attach delete handlers
    historyList.querySelectorAll('button.ghost').forEach(b=>{
      b.addEventListener('click', (e)=>{
        const idx = Number(b.dataset.index);
        const arr = loadHistory();
        arr.splice(idx,1);
        saveHistory(arr);
        showToast('Entry deleted');
      });
    });
  }

  function exportCSV(){
    const arr = loadHistory();
    if(arr.length===0){ showToast('No history to export'); return; }
    const headers = ['date','cycles','seconds','config'];
    const rows = arr.map(r => headers.map(h=>`"${(r[h]||'').toString().replace(/"/g,'""')}"`).join(',')).join('\n');
    const csv = headers.join(',') + '\n' + rows;
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url;
    a.download = `breathe-history-${new Date().toISOString().slice(0,10)}.csv`;
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    showToast('Exported CSV');
  }

  function clearHistory(){
    if(!confirm('Clear all saved history?')) return;
    localStorage.removeItem(STORAGE);
    renderHistory();
    updateSummary();
    showToast('History cleared');
  }

  function showToast(msg, ms=1400){
    let t = document.getElementById('__bt_toast__');
    if(!t){
      t = document.createElement('div'); t.id='__bt_toast__';
      t.style.position='fixed'; t.style.right='18px'; t.style.bottom='18px';
      t.style.padding='10px 14px'; t.style.background='#0f1724'; t.style.color='#fff';
      t.style.borderRadius='8px'; t.style.boxShadow='0 10px 30px rgba(2,6,23,0.3)';
      t.style.opacity='0'; t.style.transition='all .18s'; document.body.appendChild(t);
    }
    t.textContent = msg; t.style.opacity='1'; t.style.transform='translateY(0)';
    clearTimeout(t._tm); t._tm = setTimeout(()=> t.style.opacity='0', ms);
  }

  // presets click
  presetsWrap.querySelectorAll('.pill').forEach(p=>{
    p.addEventListener('click', ()=>{
      presetsWrap.querySelectorAll('.pill').forEach(x=>x.classList.remove('active'));
      p.classList.add('active');
      if(p.id === 'customPreset') return;
      inhaleInput.value = p.dataset.inhale;
      holdInput.value = p.dataset.hold;
      exhaleInput.value = p.dataset.exhale;
      hold2Input.value = p.dataset.hold2;
      cyclesInput.value = p.dataset.cycles;
    });
  });

  // Attach controls
  startBtn.addEventListener('click', startSession);
  pauseBtn.addEventListener('click', pauseSession);
  stopBtn.addEventListener('click', stopSession);
  skipBtn.addEventListener('click', skipPhase);

  document.getElementById('exportBtn').addEventListener('click', exportCSV);
  document.getElementById('clearBtn').addEventListener('click', clearHistory);

  // make ring responsive to window resize (no-op but keeps transitions)
  window.addEventListener('resize', ()=>{});

  // initial render
  renderHistory(); updateSummary();

  // ensure session status saved on page close (not required, but safe)
  window.addEventListener('beforeunload', ()=> {
    // nothing critical to save; sessions are ephemeral
  });

  // keyboard: space starts/stops
  document.addEventListener('keydown', (e)=>{
    if(e.code === 'Space' && document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA'){
      e.preventDefault();
      if(!session) startSession();
      else if(session && session.running) pauseSession();
      else if(session && session.paused) pauseSession();
    }
  });

  // render loop to sync CSS transitions with JS remaining time (for smoother UI)
  // We don't rely on requestAnimationFrame for timing accuracy; setTimeout controls phases.
  // But update cycle label every second:
  setInterval(()=> {
    if(session){
      // update cycle label: show completed cycles + (currentPhaseIndex>0?1:0)
      const cyclesDone = session.completedCycles + (session.currentPhaseIndex>0 ? 1 : 0);
      cycleLabel.textContent = `Cycles: ${Math.min(cyclesDone, session.cyclesTotal)} / ${session.cyclesTotal}`;
    }
  }, 850);

  // expose for debugging (optional)
  window.__breathe = { start: startSession, stop: stopSession, history: loadHistory };

  // renderHistory initial
  renderHistory();

})();
</script>
</body>
</html>